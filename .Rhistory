lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M)
p=200
n=100
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
y
x%*%array(0,length(y))
dim(x = )
dim(x )
beta.0
x
x*beta
x*beta.0
x%*%beta.0
beta.0=array(1,c(n,1))
p=200
n=100
beta.0=array(1,c(n,1))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
p=200
n=100
beta.0=array(1,c(1,n))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
remove.packages("LassoNet")
install.packages("~/Dropbox/PhD/Projects/3CoSE/LassoNet_0.8.3.tar.gz", repos = NULL, type = "source")
p=200
n=100
beta.0=array(1,c(1,n))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
beta.0=array(1,c(n,1))
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
p=100
n=100
beta.0=array(1,c(n,1))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
p=200
n=100
beta.0=array(1,c(p,1))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
p<-200
> n<-100
> x<-matrix(rnorm(n*p),n,p)
> y<-rnorm(n,mean=0,sd=1)
> fastols(y,x)
p<-200
n<-100x<-matrix(rnorm(n*p),n,p)
> y<-rnorm(n,mean=0,sd=1)
> fastols(y,x)
p<-200
n<-100
x<-matrix(rnorm(n*p),n,p)
y<-rnorm(n,mean=0,sd=1)
fastols(y,x)
x
y
p<-200
n<-100
x<-5*matrix(rnorm(n*p),n,p)
y<-rnorm(n,mean=0,sd=1)
fastols(y,x)
x
p<-200
n<-100
x<-matrix(rnorm(n*p),n,p)
y<-5*x + rnorm(n,mean=0,sd=1)
fastols(y,x)
x
y
p<-200
n<-100
x<-matrix(rnorm(n*p),n,p)
y<-array(5, c(p,1))*x + rnorm(n,mean=0,sd=1)
fastols(y,x)
y
p<-200
n<-100
x<-matrix(rnorm(n*p),n,p)
beta<-array(5, c(p,1))
y<-beta%*%x + rnorm(n,mean=0,sd=1)
y<-x%*%beta + rnorm(n,mean=0,sd=1)
fastols(y,x)
y
fastols
XtX <- crossprod(x)
XtX
fastols
Xty <- crossprod(x, y)
solve(XtX, Xty)
x%*%beta
y<-x%*%beta + rnorm(n,mean=0,sd=0.1)
y
fastols(y,x)
p<-10
n<-100
x<-matrix(rnorm(n*p),n,p)
beta<-array(5, c(p,1))
y<-x%*%beta + rnorm(n,mean=0,sd=0.1)
fastols(y,x)
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- FALSE
opt.method <- "nelder-mead"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5,0.5)
z <- list(y = as.matrix(dataCAViaR))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- FALSE
opt.method <- "nelder-mead"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5,0.5)
z <- list(y = as.matrix(dataCAViaR))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
fit
dataCAViaR
dataCAViaR[,1:2]
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- FALSE
opt.method <- "nelder-mead"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- FALSE
opt.method <- "nelder-mead"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
fit
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- FALSE
opt.method <- "cma-es"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
fit
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- c(FALSE,TRUE)
opt.method <- "cma-es"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
p <- ncol(z$y)
if(length(theta)==1){theta=rep(theta,p)}
if(length(theta)!=p){stop("number of quantile levels must equal to the number of covariates")}
if(length(is.midas)==1){is.midas=rep(is.midas,p)}
if(length(is.midas)>p){stop("number of MIDAS weighted covariates must not exceed total number of covariates")}
if(length(opt.transform)<p){opt.transform=c(opt.transform,rep("lev",p-length(opt.transform)))}
if(length(opt.transform)>p){stop("number of transformations exceed total number of covariates")}
Y<-X<-a<-r<-c<-fit.u<-dat<-e.q<-kappa<-NULL
for(i in 1:p){
dat$y <- z$y[,i]
fit.u[[i]] <- fit.u.dyn.quant(theta[i],dat,type,is.midas[i],opt.method,opt.transform[i],mc,quant.type,dq.options)
coeffs <- coef(fit.u[[i]])
c[i] <- coeffs[1]
a[i] <- coeffs[2] # autoregressive coefficient
r[i] <- coeffs[3] # realized coefficient
kappa[i] <- coeffs[4]
e.q[i] <- fit.u[[i]]$empirical.quantile
Y[[i]] <- fit.u[[i]]$Y
X[[i]] <- fit.u[[i]]$X
}
dq.options
dq.options=NULL
p <- ncol(z$y)
if(length(theta)==1){theta=rep(theta,p)}
if(length(theta)!=p){stop("number of quantile levels must equal to the number of covariates")}
if(length(is.midas)==1){is.midas=rep(is.midas,p)}
if(length(is.midas)>p){stop("number of MIDAS weighted covariates must not exceed total number of covariates")}
if(length(opt.transform)<p){opt.transform=c(opt.transform,rep("lev",p-length(opt.transform)))}
if(length(opt.transform)>p){stop("number of transformations exceed total number of covariates")}
Y<-X<-a<-r<-c<-fit.u<-dat<-e.q<-kappa<-NULL
for(i in 1:p){
dat$y <- z$y[,i]
fit.u[[i]] <- fit.u.dyn.quant(theta[i],dat,type,is.midas[i],opt.method,opt.transform[i],mc,quant.type,dq.options)
coeffs <- coef(fit.u[[i]])
c[i] <- coeffs[1]
a[i] <- coeffs[2] # autoregressive coefficient
r[i] <- coeffs[3] # realized coefficient
kappa[i] <- coeffs[4]
e.q[i] <- fit.u[[i]]$empirical.quantile
Y[[i]] <- fit.u[[i]]$Y
X[[i]] <- fit.u[[i]]$X
}
X
X[1]
X[2]
dim(X[2])
dim(X[[2]])
dim(X[[1]])
length(X[[1]])
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- c(TRUE,TRUE)
opt.method <- "cma-es"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- TRUE
opt.method <- "cma-es"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
if (is.midas){
if (is.null(dq.options$y.lowfreq) || is.null(dq.options$x.highfreq)){
if (is.null(dq.options$period)){dq.options$period <- 22}
if (is.null(dq.options$nlag)){dq.options$nlag <- 22}
}
}
dq.option<-NULL
if (is.midas){
if (is.null(dq.options$y.lowfreq) || is.null(dq.options$x.highfreq)){
if (is.null(dq.options$period)){dq.options$period <- 22}
if (is.null(dq.options$nlag)){dq.options$nlag <- 22}
}
}
dq.options<-NULL
if (is.midas){
if (is.null(dq.options$y.lowfreq) || is.null(dq.options$x.highfreq)){
if (is.null(dq.options$period)){dq.options$period <- 22}
if (is.null(dq.options$nlag)){dq.options$nlag <- 22}
}
}
p <- ncol(z$y)
if(length(theta)==1){theta=rep(theta,p)}
if(length(theta)!=p){stop("number of quantile levels must equal to the number of covariates")}
if(length(is.midas)==1){is.midas=rep(is.midas,p)}
if(length(is.midas)>p){stop("number of MIDAS weighted covariates must not exceed total number of covariates")}
if(length(opt.transform)<p){opt.transform=c(opt.transform,rep("lev",p-length(opt.transform)))}
if(length(opt.transform)>p){stop("number of transformations exceed total number of covariates")}
Y<-X<-a<-r<-c<-fit.u<-dat<-e.q<-kappa<-NULL
for(i in 1:p){
dat$y <- z$y[,i]
fit.u[[i]] <- fit.u.dyn.quant(theta[i],dat,type,is.midas[i],opt.method,opt.transform[i],mc,quant.type,dq.options)
coeffs <- coef(fit.u[[i]])
c[i] <- coeffs[1]
a[i] <- coeffs[2] # autoregressive coefficient
r[i] <- coeffs[3] # realized coefficient
kappa[i] <- coeffs[4]
e.q[i] <- fit.u[[i]]$empirical.quantile
Y[[i]] <- fit.u[[i]]$Y
X[[i]] <- fit.u[[i]]$X
}
midasr
?midasr
?midas_r
midasr::midasr::agk.test()
midasr
library("midasr", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
agk.test
gen_midas_coef
fmls(z$y[,1], 22, 22)
fmls(z$y[,1], 22)
fmls(z$y[,1], 22,22)
fmls(z$y[,1],22,22)
data("USunempr")
data("USrealgdp")
y <- diff(log(USrealgdp))
x <- window(diff(USunempr),start=1949)
trend <- 1:length(y)
mlr <- lf_lags_table(y~trend+fmls(x,12,12,nealmon),
start=list(x=rep(0,3)),
from=c(x=0),to=list(x=c(3,4)))
mlr
fmls(x,12,12,nealmon)
y
harstep(c(0.01,-0.01),3)
harstep(c(0.01,-0.01),20)
harstep
?ts
z <- list(y = as.matrix(dataCAViaR[,1:2]))
z
ts(data=z,start=1,frequency = 252)
q=ts(data=z,start=1,frequency = 252)
mask.na <- !is.na(DataY)
DataY <- z$y[,1]
# complete data
mask.na <- !is.na(DataY)
mask.na
mask.na.*TRUE
mask.na*TRUE
mask.na*FALSE
mask.na <- !is.na(DataY)
mask.nan <- !is.nan(DataY)
mask.na*mask.nan
rm(list = ls())
#change for testing
setwd('/Users/striaukas/Documents/GitHub/dynquant')
#require('zoo')
require('parallel')
require('optimx')
require("cmaes")
#require('ggplot2')
source('R/functions.R')
load("Data/dataCAViaR.RData")
type <- "cav"
quant.type <- "quant"
is.midas <- TRUE
opt.method <- "cma-es"
opt.transform <- c("abs","sq")
mc <- TRUE
theta <- c(0.01,0.5)
z <- list(y = as.matrix(dataCAViaR[,1:2]))
fit <- fit.mv.dyn.quant(theta,z,type,is.midas,opt.method,opt.transform,mc,quant.type)
if(is.null(dq.options$num.min.rq.stat.evals)){dq.options$num.min.rq.stat.evals = 1}
if (is.midas){
if (is.null(dq.options$y.lowfreq) || is.null(dq.options$x.highfreq)){
if (is.null(dq.options$period)){dq.options$period <- 22}
if (is.null(dq.options$nlag)){dq.options$nlag <- 22}
}
}
num.min.rq.stat.evals <- dq.options$num.min.rq.stat.evals
p <- ncol(z$y)
num.min.rq.stat.evals=1
p <- ncol(z$y)
if(length(theta)==1){theta=rep(theta,p)}
if(length(theta)!=p){stop("number of quantile levels must equal to the number of covariates")}
if(length(is.midas)==1){is.midas=rep(is.midas,p)}
if(length(is.midas)>p){stop("number of MIDAS weighted covariates must not exceed total number of covariates")}
if(length(opt.transform)<p){opt.transform=c(opt.transform,rep("lev",p-length(opt.transform)))}
if(length(opt.transform)>p){stop("number of transformations exceed total number of covariates")}
Y<-X<-a<-r<-c<-fit.u<-dat<-e.q<-kappa<-NULL
for(i in 1:p){
dat$y <- z$y[,i]
fit.u[[i]] <- fit.u.dyn.quant(theta[i],dat,type,is.midas[i],opt.method,opt.transform[i],mc,quant.type,dq.options)
coeffs <- coef(fit.u[[i]])
c[i] <- coeffs[1]
a[i] <- coeffs[2] # autoregressive coefficient
r[i] <- coeffs[3] # realized coefficient
kappa[i] <- coeffs[4]
e.q[i] <- fit.u[[i]]$empirical.quantile
Y[[i]] <- fit.u[[i]]$Y
X[[i]] <- fit.u[[i]]$X
}
dq.options=NULL
p <- ncol(z$y)
if(length(theta)==1){theta=rep(theta,p)}
if(length(theta)!=p){stop("number of quantile levels must equal to the number of covariates")}
if(length(is.midas)==1){is.midas=rep(is.midas,p)}
if(length(is.midas)>p){stop("number of MIDAS weighted covariates must not exceed total number of covariates")}
if(length(opt.transform)<p){opt.transform=c(opt.transform,rep("lev",p-length(opt.transform)))}
if(length(opt.transform)>p){stop("number of transformations exceed total number of covariates")}
Y<-X<-a<-r<-c<-fit.u<-dat<-e.q<-kappa<-NULL
for(i in 1:p){
dat$y <- z$y[,i]
fit.u[[i]] <- fit.u.dyn.quant(theta[i],dat,type,is.midas[i],opt.method,opt.transform[i],mc,quant.type,dq.options)
coeffs <- coef(fit.u[[i]])
c[i] <- coeffs[1]
a[i] <- coeffs[2] # autoregressive coefficient
r[i] <- coeffs[3] # realized coefficient
kappa[i] <- coeffs[4]
e.q[i] <- fit.u[[i]]$empirical.quantile
Y[[i]] <- fit.u[[i]]$Y
X[[i]] <- fit.u[[i]]$X
}
if(is.null(dq.options$empirical.quantile)){
dq.options$empirical.quantile <- e.q
}
empirical.quantile <- dq.options$empirical.quantile
pars0 <- c(c,c(diag(a)),c(diag(r)),c(kappa))
Y <- matrix(unlist(Y),ncol=p,byrow=FALSE)
pars0
z$Y <- Y
z$X <- X
starting.vals <- get.mv.initial(pars0,type,is.midas,p,num.test = 1e3)
starting.vals
if(mc) rq.stat <- mclapply(1:dim(starting.vals)[1],get.mv.best.init,
theta,z,is.midas,starting.vals,
quant.type,empirical.quantile,
mc.cores = ncores)
ncores=5
if(mc) rq.stat <- mclapply(1:dim(starting.vals)[1],get.mv.best.init,
theta,z,is.midas,starting.vals,
quant.type,empirical.quantile,
mc.cores = ncores)
rq.stat <-lapply(1:dim(starting.vals)[1],get.mv.best.init,
theta,z,is.midas,starting.vals,
quant.type,empirical.quantile)
is.midas
